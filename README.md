# TypeScript 契約プログラミングライブラリ 統合ドキュメント

このファイルは、ライブラリ開発に関するすべてのドキュメントを一つにまとめたものです。

---

## 1. 要件定義書

### 1.1. 概要

本ドキュメントは、TypeScriptで契約プログラミングを実践するための新しいライブラリ（以下、本ライブラリ）の要件を定義するものである。

#### 1.1.1. プロジェクトの目的と背景

TypeScriptの静的型チェックだけでは保証できない、より詳細なプログラムの正しさを「実行時」に検証することを目的とする。これにより、開発者はバグの早期発見、コードの堅牢性向上、そして仕様の明確化を実現できる。

---

### 1.2. 用語定義

| 用語 | 説明 |
| :--- | :--- |
| **契約 (Contract)** | プログラムのコンポーネント（関数、クラスなど）が満たすべき表明の集まり。 |
| **事前条件 (Precondition)** | 関数やメソッドが呼び出される「前」に満たされているべき条件。主に関数の引数を検証するために使用する。 |
| **事後条件 (Postcondition)** | 関数やメソッドの処理が完了した「後」に満たされているべき条件。戻り値やオブジェクトの状態変化を検証するために使用する。 |
| **不変条件 (Invariant)** | クラスのインスタンスが、公開メソッドの呼び出し前後で常に満たしているべき条件。 |

---

### 1.3. 機能要件

本ライブラリが提供すべき機能を以下に定義する。

#### 1.3.1. 事前条件の定義機能

-   [ ] 関数の実行前に、引数が特定の条件を満たすことを検証できること。
-   [ ] 条件式は、引数を受け取る関数として定義できること。
-   [ ] 条件を満たさない場合、設定に応じたエラー（または警告）を発生させること。
-   **（例）** 数値の配列を受け取り、その合計を返す関数で、配列が空でないことを保証する。

#### 1.3.2. 事後条件の定義機能

-   [ ] 関数の実行後に、戻り値が特定の条件を満たすことを検証できること。
-   [ ] 条件式は、戻り値と元の引数を受け取る関数として定義できること。
-   [ ] 条件を満たさない場合、設定に応じたエラー（または警告）を発生させること。
-   **（例）** ユーザーIDからユーザー情報を取得する関数で、戻り値が`null`でないことを保証する。

#### 1.3.3. 不変条件の定義機能

-   [ ] クラスの公開メソッド実行の前後で、インスタンスの状態が特定の条件を満たすことを検証できること。
-   [ ] 条件式は、クラスのインスタンス(`this`)を受け取る関数として定義できること。
-   [ ] 条件を満たさない場合、設定に応じたエラー（または警告）を発生させること。
-   **（例）** 銀行口座クラスで、預金残高(`balance`)が常に0以上であることを保証する。

#### 1.3.4. 設定機能

-   [ ] 契約違反時の挙動（エラーをスロー、警告を出力など）をグローバルまたは個別に設定できること。
-   [ ] `NODE_ENV`などの環境変数に応じて、契約チェックを無効化できる機能を提供すること。（本番環境でのパフォーマンス影響を避けるため）

---

### 1.4. 非機能要件

#### 1.4.1. 使いやすさ (Usability)

-   APIは直感的で、TypeScript開発者にとって学習コストが低いこと。
-   エラーメッセージは、どの契約がなぜ違反されたのかが明確にわかるように、分かりやすい情報を含むこと。

#### 1.4.2. パフォーマンス (Performance)

-   契約チェックによるオーバーヘッドが、開発の妨げにならない程度に軽量であること。
-   契約チェックを無効化した場合には、パフォーマンスへの影響がゼロになること。

#### 1.4.3. 互換性 (Compatibility)

-   最新のLTS版Node.jsおよびTypeScriptのバージョンで動作すること。
-   CommonJSとES Modulesの両方のモジュールシステムをサポートすること。

---

### 1.5. 想定される利用者

-   堅牢なアプリケーションを開発したいTypeScript開発者。
-   テスト駆動開発（TDD）やドメイン駆動設計（DDD）を実践している開発チーム。
-   コードの仕様をより明確に記述したいと考えている開発者。

---

### 1.6. 制約事項

-   本ライブラリは実行時のチェックを行うものであり、コンパイル時の静的チェックを代替するものではない。

<br>

---
---

## 2. AIのための契約プログラミング コーディング規約

### 2.1. はじめに

これからあなたに生成してもらうすべてのTypeScriptコードにおいて、以下の規約を**最優先**で遵守してください。この規約の目的は、生成されるコードの堅牢性と信頼性を保証することです。

あなたは、`@my-scope/contract` という名前の契約プログラミングライブラリの存在を前提としてコーディングを行います。

---

### 2.2. ライブラリの概要

`@my-scope/contract` は、TypeScriptの実行時アサーション（表明）を実装するためのライブラリです。以下のデコレータを提供します。

-   `@require(condition: (arg1, arg2, ...) => boolean, message: string)`
    -   **事前条件**を定義します。
    -   メソッドが実行される「前」に引数を検証します。
    -   `condition` が `false` を返した場合、エラーをスローします。

-   `@ensure(condition: (returnValue, arg1, arg2, ...) => boolean, message: string)`
    -   **事後条件**を定義します。
    -   メソッドが実行された「後」に戻り値を検証します。
    -   `condition` が `false` を返した場合、エラーをスローします。

-   `@invariant(condition: (instance: this) => boolean, message: string)`
    -   **不変条件**を定義します。
    -   クラスの公開メソッドが実行される「前後」で、インスタンスの状態を検証します。
    -   `condition` が `false` を返した場合、エラーをスローします。

---

### 2.3. 基本原則

1.  **原則、全ての公開メソッドに契約を適用せよ**: `export` されるクラスや関数の公開メソッドには、必ず1つ以上の契約を記述してください。
2.  **型システムを補完せよ**: `string` 型だけでは表現できない「空文字列でないこと」や、`number` 型だけでは表現できない「正の整数であること」など、型定義だけでは不十分な制約を契約で表現してください。
3.  **防御的にプログラミングせよ**: メソッドの内部で引数の型チェックやnullチェックを行う代わりに、契約を使って入り口で不正なデータを排除してください。

---

### 2.4. 各契約の利用ガイドライン

#### 2.4.1. `@require` (事前条件) の使い方

メソッドが正しく動作するための前提条件を表明します。

-   **チェックすべき項目**:
    -   オブジェクトが `null` や `undefined` でないこと。
    -   数値が特定の範囲内（例: 0以上）であること。
    -   文字列が空でないこと、または特定の正規表現にマッチすること。
    -   配列が空でないこと。

-   **コード例**:
    ```typescript
    import { require } from '@my-scope/contract';

    class UserService {
      @require(user => user !== null, 'User must not be null')
      @require(user => user.id > 0, 'User ID must be a positive number')
      public getUserProfile(user: { id: number; name: string }): void {
        // ...
      }
    }
    ```

#### 2.4.2. `@ensure` (事後条件) の使い方

メソッドが完了した後の成果を保証します。

-   **チェックすべき項目**:
    -   戻り値が `null` や `undefined` でないこと。
    -   戻り値の数値が特定の範囲を満たすこと。
    -   メソッド実行後に、オブジェクトの特定の状態が期待通りに変化したこと。

-   **コード例**:
    ```typescript
    import { ensure } from '@my-scope/contract';

    class UserRepository {
      @ensure(result => result !== null, 'Found user must not be null')
      @ensure((result, userId) => result.id === userId, 'Found user ID must match the requested ID')
      public findById(userId: number): User | null {
        // ... DBからユーザーを探す処理
      }
    }
    ```

#### 2.4.3. `@invariant` (不変条件) の使い方

クラスのインスタンスが、常に健全な状態を保つことを保証します。

-   **チェックすべき項目**:
    -   インスタンスのプロパティが、常に特定の条件を満たすこと（例: `count >= 0`）。
    -   複数のプロパティ間に矛盾がないこと（例: `startDate <= endDate`）。

-   **コード例**:
    ```typescript
    import { invariant, require } from '@my-scope/contract';

    @invariant(account => account.balance >= 0, 'Account balance cannot be negative')
    class BankAccount {
      public balance: number = 0;

      @require(amount => amount > 0, 'Deposit amount must be positive')
      public deposit(amount: number): void {
        this.balance += amount;
      }

      @require(amount => amount > 0, 'Withdrawal amount must be positive')
      @require((amount, self) => self.balance >= amount, 'Insufficient funds')
      public withdraw(amount: number): void {
        this.balance -= amount;
      }
    }
    ```

---

### 2.5. 最終確認

以上の規約を完全に理解し、今後のすべてのTypeScriptコード生成において、この規約を厳格に適用してください。もし規約を適用できない特別な理由がある場合は、その理由をコメントで明記してください。

<br>

---
---

## 3. 開発タスクリスト 🚀

### 3.1. フェーズ 1: プロジェクトの基礎固め (環境構築) 🏗️

-   [ ] **Gitリポジトリの作成**: コードのバージョン管理を行うために、GitHubなどで新しいリポジトリを作成します。
-   [ ] **npmプロジェクトの初期化**: `npm init -y` コマンドで `package.json` を作成します。
-   [ ] **TypeScriptの導入**: `npm install typescript @types/node --save-dev` でTypeScriptをインストールし、`npx tsc --init` で `tsconfig.json` を生成・設定します。
-   [ ] **リンターとフォーマッターの設定**: ESLintとPrettierを導入し、コードの品質とスタイルを統一します。
-   [ ] **テスト環境の構築**: VitestやJestなどのテストフレームワークを導入します。
-   [ ] **ディレクトリ構造の作成**: ソースコード用の `src`、テストコード用の `tests`、ビルド成果物用の `dist` などの基本的なフォルダを作成します。

### 3.2. フェーズ 2: コア機能の実装 (コーディング) 💻

-   [ ] **API詳細設計**: 各デコレータ (`@require`, `@ensure`, `@invariant`) が受け取る引数の型や仕様を具体的に決定します。
-   [ ] **`@require` (事前条件) デコレータの実装**: メソッド実行前に引数をチェックするデコレータを作成します。
-   [ ] **`@ensure` (事後条件) デコレータの実装**: メソッド実行後に戻り値をチェックするデコレータを作成します。
-   [ ] **`@invariant` (不変条件) デコレータの実装**: クラスの状態を常に監視するデコレータを作成します。
-   [ ] **設定機能の実装**: ライブラリの挙動（エラーのスロー/警告、ON/OFF）を制御する仕組みを作成します。

### 3.3. フェーズ 3: 品質の追求 (テスト) 🧪

-   [ ] **`@require` のユニットテスト**: 事前条件が正しく機能するか、様々なパターンでテストします。
-   [ ] **`@ensure` のユニットテスト**: 事後条件が正しく機能するか、テストします。
-   [ ] **`@invariant` のユニットテスト**: 不変条件がクラスのライフサイクルを通じて守られるか、テストします。
-   [ ] **設定機能のテスト**: ON/OFFの切り替えが正しく動作するかテストします。
-   [ ] **テストカバレッジの計測**: コードのどれくらいの割合がテストされているかを確認し、品質を可視化します。

### 3.4. フェーズ 4: ドキュメントとビルド (完成) 📜

-   [ ] **README.mdの作成**: ライブラリの目的、インストール方法、詳細な使い方を記載したドキュメントを作成します。
-   [ ] **ビルドプロセスの構築**: TypeScriptのコードを、誰もが使えるJavaScript形式（CommonJS / ES Module）に変換する仕組みを `package.json` に設定します。
-   [ ] **型定義ファイルの出力設定**: TypeScriptユーザーが快適に使えるよう、型情報 (`.d.ts`) が正しく出力されることを確認します。

### 3.5. フェーズ 5: 公開と未来へ (リリース) 🚀

-   [ ] **`package.json`の整備**: 公開に向けて、パッケージ名、バージョン、ライセンスなどの情報を整備します。
-   [ ] **npmへの公開**: `npm publish` コマンドでライブラリを公開します。
-   [ ] **CI/CDの構築**: GitHub Actionsなどを利用して、テストや公開プロセスを自動化します。
